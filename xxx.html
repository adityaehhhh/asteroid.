<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Operating Systems Lab - Practical File</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
            line-height: 1.6;
        }
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            padding: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        header h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 300;
        }
        nav {
            background-color: #fff;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        nav button {
            background-color: #667eea;
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            margin: 0 0.5rem;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        nav button:hover {
            background-color: #5a67d8;
            transform: translateY(-2px);
        }
        nav button.active {
            background-color: #4c51bf;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }
        .experiment {
            display: none;
            background: white;
            border-radius: 10px;
            padding: 2rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        .experiment.active {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .experiment h2 {
            color: #667eea;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 0.5rem;
            font-size: 1.8rem;
        }
        .aim {
            background-color: #f8f9ff;
            padding: 1.5rem;
            border-left: 4px solid #667eea;
            margin-bottom: 2rem;
            border-radius: 0 8px 8px 0;
        }
        .aim h3 {
            margin-top: 0;
            color: #4a5568;
        }
        pre {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            margin: 1rem 0;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            position: relative; /* needed for copy button absolute pos */
        }
        code { font-family: 'Courier New', monospace; }

        /* copy button style */
        .copy-btn {
            position: absolute;
            right: 12px;
            top: 12px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 6px 18px rgba(102,126,234,0.12);
            transition: transform .12s ease, opacity .12s ease;
            z-index: 10;
            font-size: 0.85rem;
        }
        .copy-btn:active { transform: translateY(1px); }
        .copy-btn.copied {
            background: linear-gradient(90deg, #16a34a, #059669);
        }

        /* small feedback text under code */
        .copy-feedback {
            display: block;
            position: absolute;
            right: 12px;
            top: 44px;
            font-size: 0.8rem;
            color: #9ca3af;
            opacity: 0;
            transition: opacity .18s ease;
            pointer-events: none;
        }
        .copy-feedback.visible { opacity: 1; }

        footer {
            text-align: center;
            padding: 1rem;
            background-color: #2d3748;
            color: white;
            margin-top: 3rem;
        }
        @media (max-width: 768px) {
            nav button {
                display: block;
                margin: 0.5rem auto;
                width: 80%;
            }
            .content {
                padding: 0 1rem;
            }
            header h1 {
                font-size: 2rem;
            }
            .copy-btn { right: 8px; top: 8px; padding:6px 8px; }
            .copy-feedback { right: 8px; top: 36px; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Operating Systems Lab</h1>
    </header>

    <nav>
        <!-- pass event to handler so we can mark the clicked button active -->
        <button onclick="showPractical(1, event)" class="active">Experiment 1: FCFS</button>
        <button onclick="showPractical(2, event)">Experiment 2: SJF</button>
        <button onclick="showPractical(3, event)">Experiment 3: Priority</button>
        <button onclick="showPractical(4, event)">Experiment 4: RR</button>
        <button onclick="showPractical(5, event)">Experiment 5: I/O Calls</button>
        <button onclick="showPractical(6, event)">Experiment 6: Bankers</button>
        <button onclick="showPractical(7, event)">Experiment 7: Producer-Consumer</button>
        <button onclick="showPractical(8, event)">Experiment 8: MFT</button>
        <button onclick="showPractical(9, event)">Experiment 9: MVT</button>
        <button onclick="showPractical(10, event)">Experiment 10: Contiguous Alloc</button>
        <button onclick="showPractical(11, event)">Experiment 11: Page Replacement</button>
    </nav>

    <div class="content">
        <div id="exp1" class="experiment active">
            <h2>EXPERIMENT 1</h2>
            <div class="aim">
                <h3>Aim:</h3>
                <p>Write a C program to simulate the First Come First Served (FCFS) Scheduling Algorithm</p>
            </div>
            <pre><button class="copy-btn" data-target="exp1-code">Copy</button><span class="copy-feedback" id="exp1-feedback">Copied!</span><code id="exp1-code">#include &lt;stdio.h&gt;
int main() {
    int n, i;
    float avg_wait = 0, avg_tat = 0;
    printf("Enter the number of processes: ");
    scanf("%d", &amp;n);
    int pid[n], bt[n], at[n], wt[n], tat[n], ct[n];
    printf("Enter Arrival Time and Burst Time for each process:\n");
    for (i = 0; i &lt; n; i++) {
        pid[i] = i + 1;
        printf("Process %d:\n", pid[i]);
        printf("Arrival Time: ");
        scanf("%d", &amp;at[i]);
        printf("Burst Time: ");
        scanf("%d", &amp;bt[i]);
    }
    for (i = 0; i &lt; n - 1; i++) {
        for (int j = 0; j &lt; n - i - 1; j++) {
            if (at[j] &gt; at[j + 1]) {
                int temp = at[j];
                at[j] = at[j + 1];
                at[j + 1] = temp;
                temp = bt[j];
                bt[j] = bt[j + 1];
                bt[j + 1] = temp;
                temp = pid[j];
                pid[j] = pid[j + 1];
                pid[j + 1] = temp;
            }
        }
    }
    ct[0] = at[0] + bt[0];
    for (i = 1; i &lt; n; i++) {
        if (at[i] &gt; ct[i - 1])
            ct[i] = at[i] + bt[i];
        else
            ct[i] = ct[i - 1] + bt[i];
    }
    for (i = 0; i &lt; n; i++) {
        tat[i] = ct[i] - at[i];
        wt[i] = tat[i] - bt[i];
        avg_tat += tat[i];
        avg_wait += wt[i];
    }
    avg_tat /= n;
    avg_wait /= n;
    printf("\n---------------------------------------------------------------\n");
    printf("PID\tAT\tBT\tCT\tTAT\tWT\n");
    printf("---------------------------------------------------------------\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\t%d\n", pid[i], at[i], bt[i], ct[i], tat[i], wt[i]);
    }
    printf("---------------------------------------------------------------\n");
    printf("Average Turnaround Time: %.2f\n", avg_tat);
    printf("Average Waiting Time: %.2f\n", avg_wait);
    printf("---------------------------------------------------------------\n");
    return 0;
}</code></pre>
        </div>

        <div id="exp2" class="experiment">
            <h2>EXPERIMENT 2</h2>
            <div class="aim">
                <h3>Aim:</h3>
                <p>Write a C program to simulate both Preemptive and Non-Preemptive versions of Shortest Job First (SJF) Scheduling.</p>
            </div>
            <pre><button class="copy-btn" data-target="exp2-code">Copy</button><span class="copy-feedback" id="exp2-feedback">Copied!</span><code id="exp2-code">#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;
struct Process {
    int pid;
    int at;
    int bt;
    int wt;
    int tat;
    int rt;
    int ct;
};
void nonPreemptiveSJF(struct Process p[], int n) {
    int completed = 0, current_time = 0;
    int is_completed[100] = {0};
    float total_wt = 0, total_tat = 0;
    while (completed != n) {
        int idx = -1, mn = INT_MAX;
        for (int i = 0; i &lt; n; i++) {
            if (p[i].at &lt;= current_time &amp;&amp; is_completed[i] == 0) {
                if (p[i].bt &lt; mn) {
                    mn = p[i].bt;
                    idx = i;
                }
                if (p[i].bt == mn) {
                    if (p[i].at &lt; p[idx].at) idx = i;
                }
            }
        }
        if (idx != -1) {
            p[idx].ct = current_time + p[idx].bt;
            p[idx].tat = p[idx].ct - p[idx].at;
            p[idx].wt = p[idx].tat - p[idx].bt;
            total_wt += p[idx].wt;
            total_tat += p[idx].tat;
            is_completed[idx] = 1;
            completed++;
            current_time = p[idx].ct;
        } else {
            current_time++;
        }
    }
    printf("\n--- Non-Preemptive SJF Scheduling ---\n");
    printf("PID\tAT\tBT\tWT\tTAT\n");
    for (int i = 0; i &lt; n; i++)
        printf("%d\t%d\t%d\t%d\t%d\n", p[i].pid, p[i].at, p[i].bt, p[i].wt, p[i].tat);
    printf("\nAverage Waiting Time: %.2f", total_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", total_tat / n);
}
void preemptiveSJF(struct Process p[], int n) {
    int completed = 0, current_time = 0, prev = -1;
    float total_wt = 0, total_tat = 0;
    for (int i = 0; i &lt; n; i++) p[i].rt = p[i].bt;
    while (completed != n) {
        int idx = -1, mn = INT_MAX;
        for (int i = 0; i &lt; n; i++) {
            if (p[i].at &lt;= current_time &amp;&amp; p[i].rt &gt; 0) {
                if (p[i].rt &lt; mn) {
                    mn = p[i].rt;
                    idx = i;
                }
                if (p[i].rt == mn) {
                    if (p[i].at &lt; p[idx].at) idx = i;
                }
            }
        }
        if (idx != -1) {
            p[idx].rt--;
            current_time++;
            if (p[idx].rt == 0) {
                p[idx].ct = current_time;
                p[idx].tat = p[idx].ct - p[idx].at;
                p[idx].wt = p[idx].tat - p[idx].bt;
                total_wt += p[idx].wt;
                total_tat += p[idx].tat;
                completed++;
            }
        } else {
            current_time++;
        }
    }
    printf("\n---Preemptive SJF (SRTF) Scheduling ---\n");
    printf("PID\tAT\tBT\tWT\tTAT\n");
    for (int i = 0; i &lt; n; i++)
        printf("%d\t%d\t%d\t%d\t%d\n", p[i].pid, p[i].at, p[i].bt, p[i].wt, p[i].tat);
    printf("\nAverage Waiting Time: %.2f", total_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", total_tat / n);
}
int main() {
    int n;
    struct Process p[100];
    printf("Enter number of processes: ");
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i++) {
        p[i].pid = i + 1;
        printf("Enter Arrival Time and Burst Time for Process %d: ", i + 1);
        scanf("%d %d", &amp;p[i].at, &amp;p[i].bt);  
    }
    nonPreemptiveSJF(p, n);
    preemptiveSJF(p, n);
    return 0;
}</code></pre>

        </div>

        <div id="exp3" class="experiment">
            <h2>EXPERIMENT 3</h2>
            <div class="aim">
                <h3>Aim:</h3>
                <p>Write a C program to simulate both Preemptive and Non-Preemptive versions of Priority Scheduling.</p>
            </div>
            <pre><button class="copy-btn" data-target="exp3-code">Copy</button><span class="copy-feedback" id="exp3-feedback">Copied!</span><code id="exp3-code">#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;
struct Process {
    int pid;
    int at;
    int bt;
    int pr;
    int wt;
    int tat;
    int rt;
    int ct;
};
void nonPreemptivePriority(struct Process p[], int n) {
    int completed = 0, current_time = 0;
    int is_completed[100] = {0};
    float total_wt = 0, total_tat = 0;
    while (completed != n) {
        int idx = -1, highest = INT_MAX;
        for (int i = 0; i &lt; n; i++) {
            if (p[i].at &lt;= current_time &amp;&amp; is_completed[i] == 0) {
                if (p[i].pr &lt; highest) {
                    highest = p[i].pr;
                    idx = i;
                }
                if (p[i].pr == highest) {
                    if (p[i].at &lt; p[idx].at) idx = i;
                }
            }
        }
        if (idx != -1) {
            p[idx].ct = current_time + p[idx].bt;
            p[idx].tat = p[idx].ct - p[idx].at;
            p[idx].wt = p[idx].tat - p[idx].bt;
            total_wt += p[idx].wt;
            total_tat += p[idx].tat;
            is_completed[idx] = 1;
            completed++;
            current_time = p[idx].ct;
        } else {
            current_time++;
        }
    }
    printf("\n--- Non-Preemptive Priority Scheduling ---\n");
    printf("PID\tAT\tBT\tPR\tWT\tTAT\n");
    for (int i = 0; i &lt; n; i++)
        printf("%d\t%d\t%d\t%d\t%d\t%d\n", p[i].pid, p[i].at, p[i].bt, p[i].pr, p[i].wt, p[i].tat);
    printf("\nAverage Waiting Time: %.2f", total_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", total_tat / n);
}
void preemptivePriority(struct Process p[], int n) {
    int completed = 0, current_time = 0;
    float total_wt = 0, total_tat = 0;
    for (int i = 0; i &lt; n; i++) p[i].rt = p[i].bt;
    while (completed != n) {
        int idx = -1, highest = INT_MAX;
        for (int i = 0; i &lt; n; i++) {
            if (p[i].at &lt;= current_time &amp;&amp; p[i].rt &gt; 0) {
                if (p[i].pr &lt; highest) {
                    highest = p[i].pr;
                    idx = i;
                }
                if (p[i].pr == highest) {
                    if (p[i].at &lt; p[idx].at) idx = i;
                }
            }
        }
        if (idx != -1) {
            p[idx].rt--;
            current_time++;
            if (p[idx].rt == 0) {
                p[idx].ct = current_time;
                p[idx].tat = p[idx].ct - p[idx].at;
                p[idx].wt = p[idx].tat - p[idx].bt;
                total_wt += p[idx].wt;
                total_tat += p[idx].tat;
                completed++;
            }
        } else {
            current_time++;
        }
    }
    printf("\n---Preemptive Priority Scheduling ---\n");
    printf("PID\tAT\tBT\tPR\tWT\tTAT\n");
    for (int i = 0; i &lt; n; i++)
        printf("%d\t%d\t%d\t%d\t%d\t%d\n", p[i].pid, p[i].at, p[i].bt, p[i].pr, p[i].wt, p[i].tat);
    printf("\nAverage Waiting Time: %.2f", total_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", total_tat / n);
}
int main() {
    int n;
    struct Process p[100];
    printf("Enter number of processes: ");
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; i++) {
        p[i].pid = i + 1;
        printf("Enter Arrival Time, Burst Time and Priority for Process %d: ", i + 1);
        scanf("%d %d %d", &amp;p[i].at, &amp;p[i].bt, &amp;p[i].pr); 
    }
    nonPreemptivePriority(p, n);
    preemptivePriority(p, n);
    return 0;
}</code></pre>
        </div>

        <div id="exp4" class="experiment">
            <h2>EXPERIMENT 4</h2>
            <div class="aim">
                <h3>Aim:</h3>
                <p>Write a C program to simulate the Round Robin (RR) Scheduling Algorithm.</p>
            </div>
            <pre><button class="copy-btn" data-target="exp4-code">Copy</button><span class="copy-feedback" id="exp4-feedback">Copied!</span><code id="exp4-code">#include &lt;stdio.h&gt;
struct Process {
    int pid;
    int at;
    int bt;
    int rt;
    int wt;
    int tat;
    int ct;
};
int main() {
    int n, tq;
    printf("Enter number of processes: ");
    scanf("%d", &amp;n);
    struct Process p[n];
    int complete = 0, current_time = 0;
    float total_wt = 0, total_tat = 0;
    for (int i = 0; i &lt; n; i++) {
        p[i].pid = i + 1;
        printf("Enter Arrival Time and Burst Time for Process %d: ", i + 1);
        scanf("%d %d", &amp;p[i].at, &amp;p[i].bt);
        p[i].rt = p[i].bt;
    }
    printf("Enter Time Quantum: ");
    scanf("%d", &amp;tq);
    int done;
    do {
        done = 1;
        for (int i = 0; i &lt; n; i++) {
            if (p[i].rt &gt; 0 &amp;&amp; p[i].at &lt;= current_time) {
                done = 0;
                if (p[i].rt &gt; tq) {
                    current_time += tq;
                    p[i].rt -= tq;
                } else {
                    current_time += p[i].rt;
                    p[i].ct = current_time;
                    p[i].tat = p[i].ct - p[i].at;
                    p[i].wt = p[i].tat - p[i].bt;
                    total_wt += p[i].wt;
                    total_tat += p[i].tat;
                    p[i].rt = 0;
                    complete++;
                }
            } else if (p[i].at &gt; current_time) {
                // If next process hasn't arrived, move time forward
                current_time++;
                break;
            }
        }
    } while (!done);
    printf("\n--- Round Robin Scheduling ---\n");
    printf("PID\tAT\tBT\tWT\tTAT\n");
    for (int i = 0; i &lt; n; i++) {
        printf("%d\t%d\t%d\t%d\t%d\n", p[i].pid, p[i].at, p[i].bt, p[i].wt, p[i].tat);
    }
    printf("\nAverage Waiting Time: %.2f", total_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", total_tat / n);
    return 0;
}</code></pre>
        </div>

        <div id="exp5" class="experiment">
            <h2>EXPERIMENT 5</h2>
            <div class="aim">
                <h3>Aim:</h3>
                <p>Write programs using I/O system calls of UNIX/LINUX (open, read, write, close, fcntl, seek, stat, opendir, readdir).</p>
            </div>
            <pre><button class="copy-btn" data-target="exp5-code">Copy</button><span class="copy-feedback" id="exp5-feedback">Copied!</span><code id="exp5-code">#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;dirent.h&gt;
int main() {
    int fd1, fd2, fd3;
    char buf[256];
    ssize_t n;
    fd1 = open("test.txt", O_RDONLY);
    fd2 = open("copy.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    while ((n = read(fd1, buf, sizeof(buf))) &gt; 0)
        write(fd2, buf, n);
    lseek(fd1, 0, SEEK_SET);
    printf("\n--- Content after seeking 5 bytes ---\n");
    lseek(fd1, 5, SEEK_SET);
    n = read(fd1, buf, 20);
    write(1, buf, n);
    fd3 = dup(fd1);
    printf("\n--- Content from duplicate descriptor ---\n");
    n = read(fd3, buf, 20);
    write(1, buf, n);
    struct stat s;
    stat("test.txt", &amp;s);
    printf("\n\n--- File Information ---\n");
    printf("File Size: %ld bytes\n", s.st_size);
    printf("Links: %ld\n", s.st_nlink);
    printf("Permissions: %o\n", s.st_mode);
    DIR *d;
    struct dirent *de;
    d = opendir(".");
    printf("\n--- Directory Contents ---\n");
    while ((de = readdir(d)) != NULL)
        printf("%s\n", de-&gt;d_name);
    closedir(d);
    close(fd1);
    close(fd2);
    close(fd3);
    return 0;
}</code></pre>
        </div>

        <div id="exp6" class="experiment">
            <h2>EXPERIMENT 6</h2>
            <div class="aim">
                <h3>Aim:</h3>
                <p>Write a C program to simulate Bankers Algorithm for Deadlock Avoidance and Prevention.</p>
            </div>
            <pre><button class="copy-btn" data-target="exp6-code">Copy</button><span class="copy-feedback" id="exp6-feedback">Copied!</span><code id="exp6-code">#include &lt;stdio.h&gt;
int main() {
    int n, m;
    printf("Enter number of processes: ");
    scanf("%d", &amp;n);
    printf("Enter number of resources: ");
    scanf("%d", &amp;m);
    int alloc[n][m], max[n][m], avail[m], need[n][m], finish[n];
    int safeSeq[n], index = 0;
    printf("Enter Allocation Matrix:\n");
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; m; j++)
            scanf("%d", &amp;alloc[i][j]);
    printf("Enter Max Matrix:\n");
    for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; m; j++)
            scanf("%d", &amp;max[i][j]);
    printf("Enter Available Resources:\n");
    for (int j = 0; j &lt; m; j++)
        scanf("%d", &amp;avail[j]);
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++)
            need[i][j] = max[i][j] - alloc[i][j];
        finish[i] = 0;
    }
    int count = 0;
    while (count &lt; n) {
        int found = 0;
        for (int i = 0; i &lt; n; i++) {
            if (finish[i] == 0) {
                int j;
                for (j = 0; j &lt; m; j++)
                    if (need[i][j] &gt; avail[j])
                        break;
                if (j == m) {
                    for (int k = 0; k &lt; m; k++)
                        avail[k] += alloc[i][k];
                    safeSeq[index++] = i;
                    finish[i] = 1;
                    found = 1;
                    count++;
                }
            }
        }
        if (!found) {
            printf("\nSystem is not in a safe state.\n");
            return 0;
        }
    }
    printf("\nSystem is in a safe state.\nSafe Sequence: ");
    for (int i = 0; i &lt; n; i++)
        printf("P%d ", safeSeq[i]);
    printf("\n");
    return 0;
}</code></pre>
        </div>

        <div id="exp7" class="experiment">
            <h2>EXPERIMENT 7</h2>
            <div class="aim">
                <h3>Aim:</h3>
                <p>Write a C program to simulate Producer-Consumer Problem using Semaphores.</p>
            </div>
            <pre><button class="copy-btn" data-target="exp7-code">Copy</button><span class="copy-feedback" id="exp7-feedback">Copied!</span><code id="exp7-code">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int mutex = 1;
int full = 0;
int empty;
int item = 0;
int wait(int s) {
    return (--s);
}
int signal(int s) {
    return (++s);
}
void producer() {
    mutex = wait(mutex);
    full = signal(full);
    empty = wait(empty);
    item++;
    printf("Producer produces item %d\n", item);
    mutex = signal(mutex);
}
void consumer() {
    mutex = wait(mutex);
    full = wait(full);
    empty = signal(empty);
    printf("Consumer consumes item %d\n", item);
    item--;
    mutex = signal(mutex);
}
int main() {
    int n, choice;
    printf("Enter buffer size: ");
    scanf("%d", &amp;empty);
    while (1) {
        printf("\n1. Produce\n2. Consume\n3. Exit\nEnter your choice: ");
        scanf("%d", &amp;choice);
        switch (choice) {
            case 1:
                if ((mutex == 1) &amp;&amp; (empty != 0))
                    producer();
                else
                    printf("Buffer is full!\n");
                break;
            case 2:
                if ((mutex == 1) &amp;&amp; (full != 0))
                    consumer();
                else
                    printf("Buffer is empty!\n");
                break;
            case 3:
                exit(0);
                break;
            default:
                printf("Invalid choice!\n");
        }
    }
}</code></pre>
        </div>

        <div id="exp8" class="experiment">
            <h2>EXPERIMENT 8</h2>
            <div class="aim">
                <h3>Aim:</h3>
                <p>Write a C program to implement and simulate the MFT (Memory Management with Fixed Partitioning Technique).</p>
            </div>
            <pre><button class="copy-btn" data-target="exp8-code">Copy</button><span class="copy-feedback" id="exp8-feedback">Copied!</span><code id="exp8-code">#include &lt;stdio.h&gt;
int main() {
    int ms, ps, nob, ef, n, mp[10], tif = 0, i, j = 0;
    printf("Enter the total memory size (in KB): ");
    scanf("%d", &amp;ms);
    printf("Enter the partition size (in KB): ");
    scanf("%d", &amp;ps);
    nob = ms / ps;
    ef = ms - nob * ps;
    printf("\nTotal memory divided into %d partitions each of size %d KB\n", nob, ps);
    printf("Enter number of processes: ");
    scanf("%d", &amp;n);
    printf("Enter memory required for each process (in KB):\n");
    for (i = 0; i &lt; n; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &amp;mp[i]);
    }
    printf("\nProcess\tMemory Required\tAllocated\tInternal Fragmentation\n");
    for (i = 0; i &lt; n &amp;&amp; j &lt; nob; i++) {
        if (mp[i] &gt; ps)
            printf("P%d\t%d KB\t\tNot Allocated\t---\n", i + 1, mp[i]);
        else {
            printf("P%d\t%d KB\t\tAllocated\t%d KB\n", i + 1, mp[i], ps - mp[i]);
            tif += ps - mp[i];
            j++;
        }
    }
    if (i &lt; n)
        printf("\nMemory Full. Remaining processes cannot be allocated.\n");
    printf("\nTotal Internal Fragmentation: %d KB\n", tif);
    printf("Total External Fragmentation: %d KB\n", ef);
    return 0;
}</code></pre>
        </div>

        <div id="exp9" class="experiment">
            <h2>EXPERIMENT 9</h2>
            <div class="aim">
                <h3>Aim:</h3>
                <p>Write a C program to implement and simulate the MVT (Memory Variable Partitioning Technique).</p>
            </div>
            <pre><button class="copy-btn" data-target="exp9-code">Copy</button><span class="copy-feedback" id="exp9-feedback">Copied!</span><code id="exp9-code">#include &lt;stdio.h&gt;
int main() {
    int ms, mp[10], n, i;
    int temp, available, allocated = 0;
    printf("Enter total memory available (in KB): ");
    scanf("%d", &amp;ms);
    available = ms;
    printf("Enter number of processes: ");
    scanf("%d", &amp;n);
    printf("Enter memory required for each process (in KB):\n");
    for (i = 0; i &lt; n; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &amp;mp[i]);
    }
    printf("\nProcess\tMemory Required\tAllocated\tRemaining Memory\n");
    for (i = 0; i &lt; n; i++) {
        if (mp[i] &lt;= available) {
            printf("P%d\t%d KB\t\tYes\t\t%d KB\n", i + 1, mp[i], available - mp[i]);
            available -= mp[i];
            allocated += mp[i];
        } else {
            printf("P%d\t%d KB\t\tNo\t\t---\n", i + 1, mp[i]);
        }
    }
    printf("\nTotal Memory: %d KB", ms);
    printf("\nTotal Allocated Memory: %d KB", allocated);
    printf("\nTotal Free Memory: %d KB", available);
    printf("\nExternal Fragmentation: %d KB\n", available);
    return 0;
}</code></pre>
        </div>

        <div id="exp10" class="experiment">
            <h2>EXPERIMENT 10</h2>
            <div class="aim">
                <h3>Aim:</h3>
                <p>Write a C program to simulate Contiguous Memory Allocation techniques: Best-fit, Worst-fit, First-fit.</p>
            </div>
            <pre><button class="copy-btn" data-target="exp10-code">Copy</button><span class="copy-feedback" id="exp10-feedback">Copied!</span><code id="exp10-code">#include &lt;stdio.h&gt;
void firstFit(int blockSize[], int m, int processSize[], int n) {
    int allocation[n];
    for (int i = 0; i &lt; n; i++)
        allocation[i] = -1;
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; m; j++) {
            if (blockSize[j] &gt;= processSize[i]) {
                allocation[i] = j;
                blockSize[j] -= processSize[i];
                break;
            }
        }
    }
    printf("\nFirst Fit Allocation:\n");
    printf("Process\tSize\tBlock\n");
    for (int i = 0; i &lt; n; i++) {
        if (allocation[i] != -1)
            printf("P%d\t%d\tB%d\n", i + 1, processSize[i], allocation[i] + 1);
        else
            printf("P%d\t%d\tNot Allocated\n", i + 1, processSize[i]);
    }
}
void bestFit(int blockSize[], int m, int processSize[], int n) {
    int allocation[n];
    for (int i = 0; i &lt; n; i++)
        allocation[i] = -1;
    for (int i = 0; i &lt; n; i++) {
        int bestIdx = -1;
        for (int j = 0; j &lt; m; j++) {
            if (blockSize[j] &gt;= processSize[i]) {
                if (bestIdx == -1 || blockSize[j] &lt; blockSize[bestIdx])
                    bestIdx = j;
            }
        }
        if (bestIdx != -1) {
            allocation[i] = bestIdx;
            blockSize[bestIdx] -= processSize[i];
        }
    }
    printf("\nBest Fit Allocation:\n");
    printf("Process\tSize\tBlock\n");
    for (int i = 0; i &lt; n; i++) {
        if (allocation[i] != -1)
            printf("P%d\t%d\tB%d\n", i + 1, processSize[i], allocation[i] + 1);
        else
            printf("P%d\t%d\tNot Allocated\n", i + 1, processSize[i]);
    }
}
void worstFit(int blockSize[], int m, int processSize[], int n) {
    int allocation[n];
    for (int i = 0; i &lt; n; i++)
        allocation[i] = -1;
    for (int i = 0; i &lt; n; i++) {
        int worstIdx = -1;
        for (int j = 0; j &lt; m; j++) {
            if (blockSize[j] &gt;= processSize[i]) {
                if (worstIdx == -1 || blockSize[j] &gt; blockSize[worstIdx])
                    worstIdx = j;
            }
        }
        if (worstIdx != -1) {
            allocation[i] = worstIdx;
            blockSize[worstIdx] -= processSize[i];
        }
    }
    printf("\nWorst Fit Allocation:\n");
    printf("Process\tSize\tBlock\n");
    for (int i = 0; i &lt; n; i++) {
        if (allocation[i] != -1)
            printf("P%d\t%d\tB%d\n", i + 1, processSize[i], allocation[i] + 1);
        else
            printf("P%d\t%d\tNot Allocated\n", i + 1, processSize[i]);
    }
}
int main() {
    int m, n;
    printf("Enter number of memory blocks: ");
    scanf("%d", &amp;m);
    int blockSize[m];
    printf("Enter size of each block:\n");
    for (int i = 0; i &lt; m; i++)
        scanf("%d", &amp;blockSize[i]);
    printf("Enter number of processes: ");
    scanf("%d", &amp;n);
    int processSize[n];
    printf("Enter size of each process:\n");
    for (int i = 0; i &lt; n; i++)
        scanf("%d", &amp;processSize[i]);
    int b1[m], b2[m], b3[m];
    for (int i = 0; i &lt; m; i++) {
        b1[i] = b2[i] = b3[i] = blockSize[i];
    }
    firstFit(b1, m, processSize, n);
    bestFit(b2, m, processSize, n);
    worstFit(b3, m, processSize, n);
    return 0;
}</code></pre>

        </div>

        <div id="exp11" class="experiment">
            <h2>EXPERIMENT 11</h2>
            <div class="aim">
                <h3>Aim:</h3>
                <p>Write a C program to implement Page Replacement techniques: FIFO, LRU, OPTIMAL.</p>
            </div>
            <pre><button class="copy-btn" data-target="exp11-code">Copy</button><span class="copy-feedback" id="exp11-feedback">Copied!</span><code id="exp11-code">#include &lt;stdio.h&gt;
int findLRU(int time[], int n) {
    int i, minimum = time[0], pos = 0;
    for (i = 1; i &lt; n; ++i)
        if (time[i] &lt; minimum) {
            minimum = time[i];
            pos = i;
        }
    return pos;
}
int findOptimal(int pages[], int frame[], int n, int m, int index) {
    int i, j, pos = -1, farthest = index;
    for (i = 0; i &lt; m; ++i) {
        int found = 0;
        for (j = index; j &lt; n; ++j) {
            if (frame[i] == pages[j]) {
                found = 1;
                if (j &gt; farthest) {
                    farthest = j;
                    pos = i;
                }
                break;
            }
        }
        if (!found)
            return i;
    }
    if (pos == -1)
        return 0;
    return pos;
}
void FIFO(int pages[], int n, int framesCount) {
    int frame[10], i, j, k = 0, pageFaults = 0;
    for (i = 0; i &lt; framesCount; i++) frame[i] = -1;
    printf("\nFIFO Page Replacement:\n");
    for (i = 0; i &lt; n; i++) {
        int flag = 0;
        for (j = 0; j &lt; framesCount; j++)
            if (frame[j] == pages[i]) {
                flag = 1;
                break;
            }
        if (flag == 0) {
            frame[k] = pages[i];
            k = (k + 1) % framesCount;
            pageFaults++;
        }
        printf("Page %d: ", pages[i]);
        for (j = 0; j &lt; framesCount; j++)
            if (frame[j] != -1)
                printf("%d ", frame[j]);
        printf("\n");
    }
    printf("Total Page Faults = %d\n", pageFaults);
}
void LRU(int pages[], int n, int framesCount) {
    int frame[10], time[10], counter = 0, i, j, pos, flag1, flag2, pageFaults = 0;
    for (i = 0; i &lt; framesCount; i++) frame[i] = -1;
    printf("\nLRU Page Replacement:\n");
    for (i = 0; i &lt; n; ++i) {
        flag1 = flag2 = 0;
        for (j = 0; j &lt; framesCount; ++j)
            if (frame[j] == pages[i]) {
                counter++;
                time[j] = counter;
                flag1 = flag2 = 1;
                break;
            }
        if (flag1 == 0) {
            for (j = 0; j &lt; framesCount; ++j)
                if (frame[j] == -1) {
                    counter++;
                    pageFaults++;
                    frame[j] = pages[i];
                    time[j] = counter;
                    flag2 = 1;
                    break;
                }
        }
        if (flag2 == 0) {
            pos = findLRU(time, framesCount);
            counter++;
            pageFaults++;
            frame[pos] = pages[i];
            time[pos] = counter;    
        }
        printf("Page %d: ", pages[i]);
        for (j = 0; j &lt; framesCount; j++)
            if (frame[j] != -1)
                printf("%d ", frame[j]);
        printf("\n"); 
    }
    printf("Total Page Faults = %d\n", pageFaults);
}
void OPTIMAL(int pages[], int n, int framesCount) {
    int frame[10], i, j, k, pos, pageFaults = 0;
    for (i = 0; i &lt; framesCount; i++) frame[i] = -1;
    printf("\nOptimal Page Replacement:\n");
    for (i = 0; i &lt; n; i++) {
        int flag = 0;
        for (j = 0; j &lt; framesCount; j++)
            if (frame[j] == pages[i]) {
                flag = 1;
                break;
            }
        if (flag == 0) {
            if (i &lt; framesCount)
                frame[i] = pages[i];
            else {
                pos = findOptimal(pages, frame, n, framesCount, i + 1);
                frame[pos] = pages[i];
            }
            pageFaults++;  
        }
        printf("Page %d: ", pages[i]);
        for (k = 0; k &lt; framesCount; k++)
            if (frame[k] != -1)
                printf("%d ", frame[k]);
        printf("\n");   
    }
    printf("Total Page Faults = %d\n", pageFaults);
}
int main() {
    int n, framesCount;
    printf("Enter number of pages: ");
    scanf("%d", &amp;n);
    int pages[n];
    printf("Enter page reference string:\n");
    for (int i = 0; i &lt; n; i++)
        scanf("%d", &amp;pages[i]);
    printf("Enter number of frames: ");
    scanf("%d", &amp;framesCount);
    FIFO(pages, n, framesCount);
    LRU(pages, n, framesCount);
    OPTIMAL(pages, n, framesCount);
    return 0;
}</code></pre>
        </div>
    </div>

    <footer>
        <p>&copy; 2025 Operating Systems Lab - Guru Gobind Singh Indraprastha University</p>
    </footer>

    <script>
        // showPractical now receives the click event so we can mark the clicked nav button active
        function showPractical(num, evt) {
            // Hide all experiments
            const experiments = document.querySelectorAll('.experiment');
            experiments.forEach(exp => exp.classList.remove('active'));

            // Remove active class from all buttons
            const buttons = document.querySelectorAll('nav button');
            buttons.forEach(btn => btn.classList.remove('active'));

            // Show selected experiment
            const el = document.getElementById('exp' + num);
            if (el) el.classList.add('active');

            // Add active to clicked button (use evt.currentTarget for safety)
            if (evt && evt.currentTarget) {
                evt.currentTarget.classList.add('active');
            } else if (evt && evt.target) {
                evt.target.classList.add('active');
            }
        }

        // Copy logic for every copy button
        document.addEventListener('DOMContentLoaded', () => {
            const copyButtons = document.querySelectorAll('.copy-btn');

            copyButtons.forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const targetId = btn.getAttribute('data-target');
                    if (!targetId) return;
                    const codeEl = document.getElementById(targetId);
                    if (!codeEl) return;

                    const codeText = codeEl.innerText || codeEl.textContent;

                    // Try modern clipboard API first
                    try {
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            await navigator.clipboard.writeText(codeText);
                        } else {
                            // Fallback: create a temporary textarea, select and execCommand
                            const ta = document.createElement('textarea');
                            ta.value = codeText;
                            // Avoid visible layout shift
                            ta.style.position = 'fixed';
                            ta.style.left = '-9999px';
                            document.body.appendChild(ta);
                            ta.select();
                            document.execCommand('copy');
                            document.body.removeChild(ta);
                        }

                        
                        btn.classList.add('copied');
                        const feedbackId = targetId.replace('-code','-feedback');
                        const feedbackEl = document.getElementById(feedbackId);
                        if (feedbackEl) feedbackEl.classList.add('visible');

                        const originalText = btn.textContent;
                        btn.textContent = 'Copied!';
                        
                        setTimeout(() => {
                            btn.classList.remove('copied');
                            btn.textContent = originalText;
                            if (feedbackEl) feedbackEl.classList.remove('visible');
                        }, 1200);
                    } catch (err) {
                        
                        try {
                            const range = document.createRange();
                            range.selectNodeContents(codeEl);
                            const sel = window.getSelection();
                            sel.removeAllRanges();
                            sel.addRange(range);
                            alert('Unable to copy automatically â€” code selected. Press Ctrl/Cmd+C to copy.');
                        } catch (ex) {
                            alert('Copy failed. You can manually select the code and press Ctrl/Cmd+C.');
                        }
                    }
                });
            });
        });
    </script>
</body>
</html>
