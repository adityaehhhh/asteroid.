<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Design &amp; Analysis of Algorithms - Practicals</title>
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --muted:#9aa6b2;
      --accent:#6ee7b7;
      --accent-2:#60a5fa;
      --glass: rgba(255,255,255,0.03);
      --radius:12px;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(800px 400px at 10% 10%, rgba(96,165,250,0.06), transparent 8%),
        radial-gradient(600px 300px at 90% 90%, rgba(110,231,183,0.03), transparent 8%),
        var(--bg);
      color:#e6eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:28px;
    }

    .app {
      max-width:1200px;
      margin:0 auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:16px;
      padding:20px;
      box-shadow: 0 10px 30px rgba(2,6,23,0.6);
      display:grid;
      grid-template-columns: 260px 1fr;
      gap:18px;
      min-height:76vh;
    }

    header.app-header {
      grid-column: 1 / -1;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:6px;
    }

    .title {
      display:flex;
      gap:14px;
      align-items:center;
    }

    .logo {
      width:56px;height:56px;
      border-radius:12px;
      background:linear-gradient(135deg,var(--accent),var(--accent-2));
      display:flex;align-items:center;justify-content:center;
      font-weight:700;color:#052225;font-size:18px;
      box-shadow: 0 6px 20px rgba(34,197,94,0.08), inset 0 -8px 18px rgba(255,255,255,0.06);
    }

    h1{
      margin:0;
      font-size:20px;
      letter-spacing:0.2px;
    }
    p.subtitle{margin:0;color:var(--muted);font-size:13px}

    .controls {
      display:flex;
      gap:10px;
      align-items:center;
    }

    select.mode {
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.04);
      color:var(--accent-2);
      padding:8px 12px;
      border-radius:10px;
      font-weight:600;
    }

    .sidebar {
      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:12px;
      min-height:420px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
      overflow:auto;
    }

    .pr-list{
      list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px;
    }

    .pr-item{
      background:transparent;
      color:var(--muted);
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      display:flex;align-items:center;justify-content:space-between;
      border:1px solid transparent;
      transition:all .18s ease;
    }
    .pr-item:hover{transform:translateY(-3px); color:var(--accent-2); border:1px solid rgba(96,165,250,0.06)}
    .pr-item.active{
      background:linear-gradient(90deg, rgba(96,165,250,0.04), rgba(110,231,183,0.03));
      color:#dff7ff;
      border:1px solid rgba(110,231,183,0.07);
      box-shadow: 0 6px 18px rgba(2,6,23,0.5);
    }

    .content {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:var(--radius);
      padding:20px;
      min-height:420px;
      overflow:auto;
      box-shadow: 0 8px 30px rgba(2,6,23,0.5);
    }

    .meta {
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }

    .meta .labels { color:var(--muted); font-size:13px }
    .source {
      font-size:12px;color:var(--muted);
      margin-top:8px;
    }

    h2.pr-title{margin:14px 0 6px 0;font-size:18px}
    .theory {
      background: rgba(255,255,255,0.02);
      border-radius:10px;
      padding:12px;
      color:#e6f3ed;
      line-height:1.5;
      font-size:14px;
      border:1px solid rgba(255,255,255,0.02);
    }

    .code-block {
      margin-top:12px;
      position:relative;
      border-radius:10px;
      overflow:auto;
      border:1px solid rgba(255,255,255,0.02);
      background: #071021;
      padding:12px;
    }
    pre { margin:0; font-family: "Courier New", monospace; font-size:13px; color:#dff7ff; white-space:pre; }
    .code-top {
      display:flex;
      justify-content:flex-end;
      gap:8px;
      margin-bottom:8px;
    }
    button.copy-btn{
      background:linear-gradient(90deg,var(--accent-2),var(--accent));
      border:none;padding:8px 10px;border-radius:8px;color:#03202a;font-weight:700;cursor:pointer;
      box-shadow: 0 8px 20px rgba(34,197,94,0.06);
    }

    .small {
      font-size:13px;color:var(--muted);
      display:inline-block;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.01);
    }

    /* responsive */
    @media (max-width:900px){
      .app{grid-template-columns:1fr; padding:14px}
      .sidebar{order:2}
      .content{order:1}
      header.app-header{flex-direction:column;align-items:flex-start;gap:14px}
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Algorithm practicals">
    <header class="app-header">
      <div class="title">
        <div class="logo">DAA</div>
        <div>
          <h1>Design &amp; Analysis of Algorithms</h1>
          <p class="subtitle">Practical File — Aim &amp; Code (All experiments included)</p>
        </div>
      </div>

      <div class="controls">
        <label for="viewMode" style="color:var(--muted);font-size:13px">View:</label>
        <select id="viewMode" class="mode" aria-label="View mode">
          <option value="both">Aim + Code</option>
          <option value="aim">Aim Only</option>
        </select>
        <div style="font-size:12px;color:var(--muted);">Source file: <span class="small">/mnt/data/Algorithm_Lab_Record.docx</span></div>
      </div>
    </header>

    <aside class="sidebar" id="sidebar">
      <ul class="pr-list" id="prList" aria-label="List of Practicals">
        <!-- Items injected by JS -->
      </ul>
    </aside>

    <main class="content" id="mainContent">
      <div class="meta">
        <div class="labels">Selected Practical</div>
        <div class="labels">Mode: <span id="modeLabel">Aim + Code</span></div>
      </div>

      <div id="prContent" style="margin-top:12px">
        <!-- Practical content injected here -->
      </div>

      <div class="source">Document source: /mnt/data/Algorithm_Lab_Record.docx</div>
    </main>
  </div>

  <script>
    // Entire JS (one script block) - safe and self-contained.
    const practicals = [
      {
        id:1,
        title:"Experiment 1 — Iterative and Recursive Binary Search",
        theory:`Binary Search uses divide-and-conquer to locate an element efficiently in a sorted array.`,
        code:`#include <stdio.h>

int iterativeBinarySearch(int arr[], int n, int key) {
    int low = 0, high = n - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == key)
            return mid;
        else if (arr[mid] < key)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}

int recursiveBinarySearch(int arr[], int low, int high, int key) {
    if (low > high) return -1;
    int mid = (low + high) / 2;
    if (arr[mid] == key)
        return mid;
    else if (arr[mid] > key)
        return recursiveBinarySearch(arr, low, mid - 1, key);
    else
        return recursiveBinarySearch(arr, mid + 1, high, key);
}

int main() {
    int arr[] = {2, 4, 6, 8, 10, 12, 14};
    int n = 7, key = 10;
    int result = iterativeBinarySearch(arr, n, key);
    if (result != -1)
        printf("Iterative: Element found at index %d\\n", result);
    else
        printf("Iterative: Element not found\\n");

    result = recursiveBinarySearch(arr, 0, n - 1, key);
    if (result != -1)
        printf("Recursive: Element found at index %d\\n", result);
    else
        printf("Recursive: Element not found\\n");

    return 0;
}`},
      {
        id:2,
        title:"Experiment 2 — Quick Sort",
        theory:`Quick sort uses divide-and-conquer by partitioning the array around a pivot element.`,
        code:`#include <stdio.h>

void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; }

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\\n");
}

int main() {
    int n;
    printf("Enter number of elements: ");
    scanf("%d", &n);
    int arr[n];
    printf("Enter %d elements:\\n", n);
    for (int i = 0; i < n; i++) scanf("%d", &arr[i]);

    printf("\\nUnsorted array:\\n");
    printArray(arr, n);
    quickSort(arr, 0, n - 1);
    printf("\\nSorted array (Ascending Order):\\n");
    printArray(arr, n);
    return 0;
}`},
      {
        id:3,
        title:"Experiment 3 — Merge Sort",
        theory:`Merge Sort divides the array into halves, sorts them recursively, and merges results.`,
        code:`#include <stdio.h>

void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    int L[n1], R[n2];
    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i]; i++;
        } else {
            arr[k] = R[j]; j++;
        }
        k++;
    }
    while (i < n1) { arr[k] = L[i]; i++; k++; }
    while (j < n2) { arr[k] = R[j]; j++; k++; }
}

void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\\n");
}

int main() {
    int n;
    printf("Enter number of elements: ");
    scanf("%d", &n);
    int arr[n];
    printf("Enter %d elements:\\n", n);
    for (int i = 0; i < n; i++) scanf("%d", &arr[i]);

    printf("\\nUnsorted array:\\n"); printArray(arr, n);
    mergeSort(arr, 0, n - 1);
    printf("\\nSorted array (Ascending Order):\\n"); printArray(arr, n);
    return 0;
}`},
      {
        id:4,
        title:"Experiment 4 — Heap Sort",
        theory:`Heap Sort converts the array into a max heap and repeatedly extracts the largest element.`,
        code:`#include <stdio.h>

void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;
    if (largest != i) {
        int temp = arr[i]; arr[i] = arr[largest]; arr[largest] = temp;
        heapify(arr, n, largest);
    }
}

void heapSort(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);
    for (int i = n - 1; i >= 0; i--) {
        int temp = arr[0];
        arr[0] = arr[i]; arr[i] = temp;
        heapify(arr, i, 0);
    }
}

void printArray(int arr[], int n) { for (int i = 0; i < n; i++) printf("%d ", arr[i]); printf("\\n"); }

int main() {
    int n;
    printf("Enter number of elements: ");
    scanf("%d", &n);
    int arr[n];
    printf("Enter %d elements:\\n", n);
    for (int i = 0; i < n; i++) scanf("%d", &arr[i]);

    printf("\\nUnsorted array:\\n"); printArray(arr, n);
    heapSort(arr, n);
    printf("\\nSorted array (Ascending Order):\\n"); printArray(arr, n);
    return 0;
}`},
      {
        id:5,
        title:"Experiment 5 — Insertion Sort",
        theory:`Insertion Sort builds the sorted array one element at a time by comparing and shifting elements.`,
        code:`#include <stdio.h>

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i]; int j = i - 1;
        while (j >= 0 && arr[j] > key) { arr[j + 1] = arr[j]; j--; }
        arr[j + 1] = key;
    }
}

void printArray(int arr[], int n) { for (int i = 0; i < n; i++) printf("%d ", arr[i]); printf("\\n"); }

int main() {
    int n;
    printf("Enter number of elements: ");
    scanf("%d", &n);
    int arr[n];
    printf("Enter %d elements:\\n", n);
    for (int i = 0; i < n; i++) scanf("%d", &arr[i]);

    printf("\\nUnsorted array:\\n"); printArray(arr, n);
    insertionSort(arr, n);
    printf("\\nSorted array (Ascending Order):\\n"); printArray(arr, n);
    return 0;
}`},
      {
        id:6,
        title:"Experiment 6 — Selection Sort",
        theory:`Selection Sort finds the minimum element in each pass and places it in the correct position.`,
        code:`#include <stdio.h>

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) { if (arr[j] < arr[minIndex]) minIndex = j; }
        if (minIndex != i) { int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; }
    }
}

void printArray(int arr[], int n) { for (int i = 0; i < n; i++) printf("%d ", arr[i]); printf("\\n"); }

int main() {
    int n;
    printf("Enter number of elements: ");
    scanf("%d", &n);
    int arr[n];
    printf("Enter %d elements:\\n", n);
    for (int i = 0; i < n; i++) scanf("%d", &arr[i]);

    printf("\\nUnsorted array:\\n"); printArray(arr, n);
    selectionSort(arr, n);
    printf("\\nSorted array (Ascending Order):\\n"); printArray(arr, n);
    return 0;
}`},
      {
        id:7,
        title:"Experiment 7i — Fractional Knapsack (Greedy)",
        theory:`Greedy Knapsack selects items based on the maximum value-to-weight ratio. It provides an approximate solution for the fractional knapsack problem.`,
        code:`#include <stdio.h>
struct Item { int weight; int profit; };

void swap(struct Item *a, struct Item *b) { struct Item temp = *a; *a = *b; *b = temp; }

void sortByRatio(struct Item items[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            float r1 = (float)items[i].profit / items[i].weight;
            float r2 = (float)items[j].profit / items[j].weight;
            if (r1 < r2) { swap(&items[i], &items[j]); }
        }
    }
}

void fractionalKnapsack(struct Item items[], int n, int capacity) {
    float totalProfit = 0.0;
    sortByRatio(items, n);
    printf("\\nItems sorted by Profit/Weight ratio:\\n");
    printf("Item\\tWeight\\tProfit\\tRatio\\n");
    for (int i = 0; i < n; i++) {
        printf("%d\\t%d\\t%d\\t%.2f\\n", i + 1, items[i].weight, items[i].profit, (float)items[i].profit / items[i].weight);
    }
    printf("\\nKnapsack process:\\n");
    for (int i = 0; i < n; i++) {
        if (capacity == 0) break;
        if (items[i].weight <= capacity) {
            capacity -= items[i].weight;
            totalProfit += items[i].profit;
            printf("Took entire item %d (Profit: %d)\\n", i + 1, items[i].profit);
        } else {
            float fraction = (float)capacity / items[i].weight;
            totalProfit += items[i].profit * fraction;
            printf("Took %.2f fraction of item %d (Added Profit: %.2f)\\n", fraction, i + 1, items[i].profit * fraction);
            capacity = 0;
        }
    }
    printf("\\nMaximum Profit = %.2f\\n", totalProfit);
}

int main() {
    int n, capacity;
    printf("Enter number of items: "); scanf("%d", &n);
    struct Item items[n];
    printf("Enter weight and profit for each item:\\n");
    for (int i = 0; i < n; i++) {
        printf("Item %d - Weight: ", i + 1); scanf("%d", &items[i].weight);
        printf("Item %d - Profit: ", i + 1); scanf("%d", &items[i].profit);
    }
    printf("Enter capacity of knapsack: "); scanf("%d", &capacity);
    fractionalKnapsack(items, n, capacity);
    return 0;
}`},
      {
        id:8,
        title:"Experiment 7ii — 0/1 Knapsack (Dynamic Programming)",
        theory:`0/1 Knapsack uses dynamic programming to choose items that maximize total value. It ensures an optimal solution with O(n·W) time complexity.`,
        code:`#include <stdio.h>

int max(int a, int b) { return (a > b) ? a : b; }

int knapSack(int capacity, int weight[], int profit[], int n) {
    int dp[n + 1][capacity + 1];
    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) {
            if (i == 0 || w == 0) dp[i][w] = 0;
            else if (weight[i - 1] <= w)
                dp[i][w] = max(profit[i - 1] + dp[i - 1][w - weight[i - 1]], dp[i - 1][w]);
            else
                dp[i][w] = dp[i - 1][w];
        }
    }
    printf("\\nDP Table:\\n");
    for (int i = 0; i <= n; i++) {
        for (int w = 0; w <= capacity; w++) printf("%3d ", dp[i][w]);
        printf("\\n");
    }
    return dp[n][capacity];
}

int main() {
    int n, capacity;
    printf("Enter number of items: "); scanf("%d", &n);
    int profit[n], weight[n];
    printf("Enter profit and weight for each item:\\n");
    for (int i = 0; i < n; i++) {
        printf("Item %d - Profit: ", i + 1); scanf("%d", &profit[i]);
        printf("Item %d - Weight: ", i + 1); scanf("%d", &weight[i]);
    }
    printf("Enter capacity of knapsack: "); scanf("%d", &capacity);
    int maxProfit = knapSack(capacity, weight, profit, n);
    printf("\\nMaximum Profit = %d\\n", maxProfit);
    return 0;
}`},
      {
        id:9,
        title:"Experiment 8 — Kruskal's Minimum Spanning Tree",
        theory:`Kruskal’s Algorithm builds a minimum spanning tree by choosing the least-weight edges. It uses the union-find method to avoid cycles.`,
        code:`#include <stdio.h>
#include <stdlib.h>

struct Edge { int u, v, weight; };
struct Graph { int V, E; struct Edge* edge; };

struct Graph* createGraph(int V, int E) {
    struct Graph* graph = (struct Graph*) malloc(sizeof(struct Graph));
    graph->V = V; graph->E = E;
    graph->edge = (struct Edge*) malloc(E * sizeof(struct Edge));
    return graph;
}

int find(int parent[], int i) {
    if (parent[i] != i) parent[i] = find(parent, parent[i]);
    return parent[i];
}

void unionSets(int parent[], int rank[], int x, int y) {
    int xroot = find(parent, x); int yroot = find(parent, y);
    if (rank[xroot] < rank[yroot]) parent[xroot] = yroot;
    else if (rank[xroot] > rank[yroot]) parent[yroot] = xroot;
    else { parent[yroot] = xroot; rank[xroot]++; }
}

int compareEdges(const void* a, const void* b) {
    struct Edge* e1 = (struct Edge*)a; struct Edge* e2 = (struct Edge*)b;
    return e1->weight - e2->weight;
}

void KruskalMST(struct Graph* graph) {
    int V = graph->V;
    struct Edge result[V];
    int e = 0, i = 0;
    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), compareEdges);
    int parent[V], rank[V];
    for (int v = 0; v < V; v++) { parent[v] = v; rank[v] = 0; }
    while (e < V - 1 && i < graph->E) {
        struct Edge nextEdge = graph->edge[i++];
        int x = find(parent, nextEdge.u); int y = find(parent, nextEdge.v);
        if (x != y) { result[e++] = nextEdge; unionSets(parent, rank, x, y); }
    }
    printf("\\nEdges in the Minimum Spanning Tree:\\n");
    int totalWeight = 0;
    for (i = 0; i < e; i++) {
        printf("%d -- %d == %d\\n", result[i].u, result[i].v, result[i].weight);
        totalWeight += result[i].weight;
    }
    printf("Total cost of MST = %d\\n", totalWeight);
}

int main() {
    int V, E;
    printf("Enter number of vertices: "); scanf("%d", &V);
    printf("Enter number of edges: "); scanf("%d", &E);
    struct Graph* graph = createGraph(V, E);
    printf("Enter edges (u v weight):\\n");
    for (int i = 0; i < E; i++) scanf("%d %d %d", &graph->edge[i].u, &graph->edge[i].v, &graph->edge[i].weight);
    KruskalMST(graph);
    free(graph->edge); free(graph);
    return 0;
}`},
      {
        id:10,
        title:"Experiment 9 — Floyd's Warshall Algorithm",
        theory:`Floyd’s Warshall computes shortest paths between all pairs of vertices. It uses a dynamic programming approach with O(n³) time complexity.`,
        code:`#include <stdio.h>
#define INF 99999

void printMatrix(int dist[][10], int V) {
    printf("\\nShortest distances between every pair of vertices:\\n");
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            if (dist[i][j] == INF) printf("%7s", "INF");
            else printf("%7d", dist[i][j]);
        }
        printf("\\n");
    }
}

void floydWarshall(int graph[][10], int V) {
    int dist[10][10];
    for (int i = 0; i < V; i++) for (int j = 0; j < V; j++) dist[i][j] = graph[i][j];
    for (int k = 0; k < V; k++) {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }
    printMatrix(dist, V);
}

int main() {
    int V;
    printf("Enter number of vertices: "); scanf("%d", &V);
    int graph[10][10];
    printf("Enter the adjacency matrix (use %d for no edge):\\n", INF);
    for (int i = 0; i < V; i++) for (int j = 0; j < V; j++) scanf("%d", &graph[i][j]);
    floydWarshall(graph, V);
    return 0;
}`},
      {
        id:11,
        title:"Experiment 10 — N-Queen Problem (Backtracking)",
        theory:`The N-Queen problem places queens on a chessboard so no two attack each other. It uses backtracking to find all valid configurations.`,
        code:`#include <stdio.h>
#include <stdlib.h>
#define MAX 20

int board[MAX][MAX];
int N;

void printSolution() {
    printf("\\nSolution:\\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) printf("%d ", board[i][j]);
        printf("\\n");
    }
}

int isSafe(int row, int col) {
    int i, j;
    for (i = 0; i < col; i++) if (board[row][i]) return 0;
    for (i = row, j = col; i >= 0 && j >= 0; i--, j--) if (board[i][j]) return 0;
    for (i = row, j = col; i < N && j >= 0; i++, j--) if (board[i][j]) return 0;
    return 1;
}

int solveNQueen(int col) {
    if (col >= N) { printSolution(); return 1; }
    int res = 0;
    for (int i = 0; i < N; i++) {
        if (isSafe(i, col)) {
            board[i][col] = 1;
            res = solveNQueen(col + 1) || res;
            board[i][col] = 0;
        }
    }
    return res;
}

int main() {
    printf("Enter the value of N: "); scanf("%d",&N);
    for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) board[i][j] = 0;
    if (!solveNQueen(0)) printf("No solution exists for N = %d\\n", N);
    return 0;
}`}
    ];

    // Populate sidebar
    const prList = document.getElementById('prList');
    practicals.forEach((p, idx) => {
      const li = document.createElement('li');
      li.className = 'pr-item' + (idx === 0 ? ' active' : '');
      li.tabIndex = 0;
      li.dataset.id = p.id;
      li.innerHTML = `<div style="font-weight:700">Exp ${p.id}</div>
                      <div style="font-size:13px;color:var(--muted)">${p.title.replace(/^Experiment \d+\s+—\s*/,'')}</div>`;
      li.addEventListener('click', () => selectPractical(p.id));
      li.addEventListener('keypress', (e) => { if (e.key === 'Enter') selectPractical(p.id); });
      prList.appendChild(li);
    });

    const modeSelect = document.getElementById('viewMode');
    const modeLabel = document.getElementById('modeLabel');

    function selectPractical(id) {
      document.querySelectorAll('.pr-item').forEach(it => {
        it.classList.toggle('active', Number(it.dataset.id) === Number(id));
      });
      renderPractical(id);
    }

    function renderPractical(id) {
      const p = practicals.find(x => Number(x.id) === Number(id));
      if (!p) { console.error('Practical not found for id:', id); return; }
      const container = document.getElementById('prContent');
      const view = modeSelect.value; // 'both' or 'aim'
      modeLabel.textContent = view === 'both' ? 'Aim + Code' : 'Aim Only';

      let html = '';
      html += `<h2 class="pr-title">${p.title}</h2>`;
      html += `<div class="theory"><strong>Theory / Aim:</strong><br>${escapeHtml(p.theory)}</div>`;

      if (view === 'both') {
        html += '<div class="code-block">';
        html += `<div class="code-top"><button class="copy-btn" data-id="${p.id}">Copy Code</button></div>`;
        html += `<pre id="code-${p.id}"></pre>`;
        html += '</div>';
      }

      container.innerHTML = html;

      if (view === 'both') {
        const pre = document.getElementById(`code-${p.id}`);
        if (pre) pre.textContent = p.code;
        const btn = container.querySelector('.copy-btn');
        if (btn) {
          btn.addEventListener('click', () => {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              navigator.clipboard.writeText(p.code).then(() => {
                const old = btn.textContent;
                btn.textContent = 'Copied ✓';
                setTimeout(() => btn.textContent = old, 1400);
              }).catch(err => {
                console.error('Clipboard write failed:', err);
                alert('Could not copy to clipboard. See console for details.');
              });
            } else {
              const ta = document.createElement('textarea');
              ta.value = p.code;
              document.body.appendChild(ta);
              ta.select();
              try {
                document.execCommand('copy');
                btn.textContent = 'Copied ✓';
                setTimeout(() => btn.textContent = 'Copy Code', 1400);
              } catch (err) {
                console.error('Fallback copy failed', err);
                alert('Copy not supported in this browser.');
              }
              document.body.removeChild(ta);
            }
          });
        }
      }
    }

    function escapeHtml(s) {
      if (typeof s !== 'string') return '';
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,'<br>');
    }

    // initial render
    if (practicals && practicals.length > 0) {
      renderPractical(practicals[0].id);
    }

    // mode change handler
    modeSelect.addEventListener('change', () => {
      const active = document.querySelector('.pr-item.active');
      if (active) renderPractical(active.dataset.id);
    });

    // keyboard nav
    document.addEventListener('keydown', (e) => {
      const active = document.querySelector('.pr-item.active');
      if (!active) return;
      if (e.key === 'ArrowDown' || e.key === 'j') {
        const next = active.nextElementSibling;
        if (next) { next.click(); next.focus(); }
      } else if (e.key === 'ArrowUp' || e.key === 'k') {
        const prev = active.previousElementSibling;
        if (prev) { prev.click(); prev.focus(); }
      }
    });
  </script>
</body>
</html>
